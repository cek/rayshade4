#! /bin/sh
#
# If these # comments don't work, trim them.  Don't worry about any
# other shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh, I'd
# suggest you cut out the prototypical config.h from the end of this
# file and edit it to reflect your system.  Some packages may include
# samples of config.h for certain machines, so you might look for one
# of those.)
#
# Yes, you may rip this off to use in other distribution packages.
# (Note: this Configure script was generated automatically.  Rather than
# working with this copy of Configure, you may wish to get metaconfig.
# Write to ram@educ.emse.fr (Raphael Manfredi) and I will send you
# my version which slightly differs from the original written by
# Larry Wall.)

# $Id: Configure,v 4.0.1.1 91/10/10 18:39:55 cek Exp Locker: cek $

: save PATH defined by user
user_path=$PATH

: sanity checks
PATH='.:/bin:/usr/bin:/usr/local/bin:/usr/ucb:/usr/local:/usr/lbin'
PATH=$PATH:'/usr/5bin:/etc:/usr/gnu/bin:/usr/new:/usr/new/bin:/usr/nbin'
PATH=$PATH:'/sys5.3/bin:/sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/ucb'
PATH=$PATH:'/bsd4.3/usr/bin:/usr/bsd'
export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh $0; kill $$)

if test ! -t 0; then
    echo "Say 'sh Configure', not 'sh <Configure'"
    exit 1
fi

(alias) >/dev/null 2>&1 && \
    echo "(I see you are using the Korn shell.  Some ksh's blow up on Configure," && \
    echo "especially on exotic machines.  If yours does, try the Bourne shell instead.)"

if test ! -d ../UU; then
    if test ! -d UU; then
	mkdir UU
    fi
    cd UU
fi

case "$1" in
-d) shift; fastread='yes';;
esac

d_eunice=''
d_xenix=''
d_bsd=''
define=''
eunicefix=''
loclist=''
expr=''
awk=''
sed=''
echo=''
cat=''
chgrp=''
chmod=''
chown=''
rm=''
mv=''
cp=''
tail=''
tr=''
mkdir=''
sort=''
uniq=''
grep=''
trylist=''
test=''
inews=''
egrep=''
more=''
pg=''
Mcc=''
vi=''
mail=''
bison=''
cpp=''
perl=''
Log=''
Header=''
Id=''
bin=''
contains=''
cppstdin=''
cppminus=''
d_bzero=''
d_cbrt=''
d_index=''
d_memset=''
d_popen=''
d_rusage=''
d_times=''
clocktype=''
i_string=''
strings=''
i_sysresrc=''
i_systypes=''
i_time=''
i_systime=''
i_systimek=''
timeincl=''
inhdr=''
inlibc=''
libs=''
models=''
split=''
small=''
medium=''
large=''
huge=''
ccflags=''
ldflags=''
cc=''
cppflags=''
optimize=''
n=''
c=''
orderlib=''
ranlib=''
package=''
randfunc=''
mrand=''
seedfunc=''
nrandbits=''
spitshell=''
shsharp=''
sharpbang=''
startsh=''
sysman=''
voidflags=''
defvoidused=''
yacc=''
d_urt=''
urtinc=''
urtlib=''
i_stdlib=''
libc=''
mkdep=''
CONFIG=''
: set package name
package=rayshade

echo " "
echo "Beginning of configuration questions for $package kit."
: Eunice requires " " instead of "", can you believe it
echo " "

define='define'
undef='undef'
: change the next line if compiling for Xenix/286 on Xenix/386
xlibpath='/usr/lib/386 /lib/386'
libpth='/usr/lib /usr/local/lib /usr/lib/large /lib '$xlibpth' /lib/large'
libpth=$libpth' /usr/lib/small /lib/small'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist='ark[1-9]isdone ark[1-9][0-9]isdone'
trap 'echo " "; rm -f $rmlist; exit 1' 1 2 3 15

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
    eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
    eunicefix=/etc/unixtovms.exe
fi

if ls blurfl >/dev/null 2>&1; then
	if awk '' blurfl >/dev/null 2>&1; then
		check='cat'
	else
		check='awk ""'
	fi
else
	check='ls'
fi

: Now test for existence of everything in MANIFEST
if test -f ../MANIFEST; then
	echo "First let's make sure your kit is complete.  Checking..."
	: some grep do not return a proper exit status
	grep '^---' ../MANIFEST > .grepmani 2>/dev/null
	if test -s .grepmani; then
(cd ..; eval $check `awk '!/^.*\/$/{if (b) print $1}
/^---/{b=1}' MANIFEST` || kill $$) >/dev/null
	else
(cd ..; eval $check `awk '!/^.*\/$/{print $1}' MANIFEST` || kill $$) >/dev/null
	fi
	echo "Looks good..."
else
	echo "No MANIFEST found. Hope your kit is complete !"
fi
rm -f .grepmani

pth="/usr/ucb /bin /usr/bin /usr/local /usr/local/bin /usr/5bin"
pth=$pth" /usr/lbin /etc /usr/new /usr/new/bin /usr/nbin /usr/gnu/bin"
pth=$pth" /usr/plx /vol/local/bin /usr/lib /lib /usr/local/lib"
pth=$pth" /sys5.3/bin /sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/bin"
pth=$pth" /bsd4.3/usr/ucb /usr/bsd"
: add PATH from user
pth=$pth" "`echo $user_path | sed -e 's/:/ /g'`
inclwanted=''
defvoidused=15
libswanted='m malloc c_s'
defvoidused=11
: some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
    contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
    contains=grep
else
    contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
    echo " "
    echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
    cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: see if sh knows # comments
echo " "
echo "Checking your sh to see if it knows about # comments..."
if sh -c '#' >/dev/null 2>&1 ; then
	echo "Your sh handles # comments correctly."
	shsharp=true
	spitshell=cat
	echo " "
	echo "Okay, let's see if #! works on this system..."
	echo "#!/bin/echo hi" > try
	$eunicefix try
	chmod +x try
	try > today
	if $contains hi today >/dev/null 2>&1; then
		echo "It does."
		sharpbang='#!'
	else
		echo "#! /bin/echo hi" > try
		$eunicefix try
		chmod +x try
		try > today
		if test -s today; then
			echo "It does."
			sharpbang='#! '
		else
			echo "#!/bin/cat" > try
			$eunicefix try
			chmod +x try
			try >today
			if test -s today; then
				echo "It does, without processing parameters."
				sharpbang='#!'
			else
				echo "It doesn't."
				sharpbang=': use '
			fi
		fi
	fi
else
	echo "Your sh doesn't grok # comments--I will strip them later on."
	shsharp=false
	echo "exec grep -v '^[ 	]*#'" >spitshell
	chmod +x spitshell
	$eunicefix spitshell
	spitshell=`pwd`/spitshell
	echo "I presume that if # doesn't work, #! won't work either!"
	sharpbang=': use '
fi
rm -f try today

: figure out how to guarantee sh startup
echo " "
echo "Checking out how to guarantee sh startup..."
startsh=$sharpbang'/bin/sh'
echo "Let's see if '$startsh' works..."
cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x try
$eunicefix try
if try; then
    echo "Yup, it does."
else
    echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
fi
rm -f try

: first determine how to suppress newline on echo command
echo " "
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
    echo "...using -n."
    n='-n'
    c=''
else
    cat <<'EOM'
...using \c
EOM
    n=''
    c='\c'
fi
echo $n "The star should be here-->$c"
echo '*'
rm -f .echotmp

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
case "\$fastread" in
yes) ans=''; echo " " ;;
*) ans='!';;
esac
while expr "X\$ans" : "X!" >/dev/null; do
    read ans
    case "\$ans" in
    !)
	sh
	echo " "
	echo $n "\$rp $c"
	;;
    !*)
	set \`expr "X\$ans" : "X!\(.*\)\$"\`
	sh -c "\$*"
	echo " "
	echo $n "\$rp $c"
	;;
    esac
done
rp='Your answer:'
case "\$ans" in
'') ans="\$dflt";;
esac
EOSC

: general instructions
cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the $package package should be installed.  If you get stuck
on a question, you may use a ! shell escape to start a subshell or execute
a command.  Many of the questions will have default answers in square
brackets--typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are
allowed to use the ~name construct to specify the login directory belonging
to "name", even if you don't have a shell which knows about that.  Questions
where this is allowed will be marked "(~name ok)".

EOH
rp="[Type carriage return to continue]"
echo $n "$rp $c"
. myread
cat <<EOH

Much effort has been expended to ensure that this shell script will run on
any Unix system. If despite that it blows up on you, your best bet is to edit
Configure and run it again. Also, let me (rayshade-request@cs.princeton.edu)
know how I blew it. If you can't run Configure for some reason, you'll have
to generate a config.sh file by hand.

This installation script affects things in two ways:
1) it may do direct variable substitutions on some of the files included
   in this kit.
2) it builds a config.h file for inclusion in C programs.  You may edit
   any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the
SH files.  Configure will offer to let you do this before it runs the SH files.

EOH
rp="[Type carriage return to continue]"
echo $n "$rp $c"
. myread

: get old answers, if there is a config file out there
if test -f ../config.sh; then
    echo " "
    dflt=y
    rp="I see a config.sh file.  Did Configure make it on THIS system? [$dflt]"
    echo $n "$rp $c"
    . myread
    case "$ans" in
    n*|N*) echo "OK, I'll ignore it.";;
    *)  echo "Fetching default answers from your old config.sh file..."
	tmp="$n"
	ans="$c"
        . ../config.sh
	n="$tmp"
	c="$ans"
	;;
    esac
fi

: find out where common programs are
echo " "
echo "Locating common programs..."
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
    case "\$thing" in
    .)
	if test -d \$dir/\$thing; then
	    echo \$dir
	    exit 0
	fi
	;;
    *)
	if test -f \$dir/\$thing; then
	    echo \$dir/\$thing
	    exit 0
	elif test -f \$dir/\$thing.exe; then
	    : on Eunice apparently
	    echo \$dir/\$thing
	    exit 0
	fi
	;;
    esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
cat
echo
expr
grep
rm
sed
sort
uniq
"
trylist="
bison
cpp
test
"
for file in $loclist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't know where $file is.  I hope it's in everyone's PATH."
	;;
    esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
ans=offhand
for file in $trylist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't see $file out there, $ans."
	ans=either
	;;
    esac
done
case "$egrep" in
egrep)
    echo "Substituting grep for egrep."
    egrep=$grep
    ;;
esac
case "$test" in
test)
    echo "Hopefully test is built into your sh."
    ;;
/bin/test)
    if sh -c "PATH= test true" >/dev/null 2>&1; then
	echo "Using the test built into your sh."
	test=test
    fi
    ;;
*)
    test=test
    ;;
esac
case "$echo" in
echo)
    echo "Hopefully echo is built into your sh."
    ;;
/bin/echo)
    echo " "
    echo "Checking compatibility between /bin/echo and builtin echo (if any)..."
    $echo $n "hi there$c" >foo1
    echo $n "hi there$c" >foo2
    if cmp foo1 foo2 >/dev/null 2>&1; then
	echo "They are compatible.  In fact, they may be identical."
    else
	case "$n" in
	'-n') n='' c='\c' ans='\c' ;;
	*) n='-n' c='' ans='-n' ;;
	esac
	cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use /bin/echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use $ans to suppress newlines now.  Life is ridiculous.

FOO
	rp="The star should be here-->"
	$echo $n "$rp$c"
	$echo "*"
    fi
    $rm -f foo1 foo2
    ;;
*)
    : cross your fingers
    echo=echo
    ;;
esac
rmlist="$rmlist loc"

: Looking for optional libraries
echo " "
echo "Checking for optional libraries..."
dflt=''
case "$libswanted" in
'') libswanted='c_s';;
esac
for thislib in $libswanted; do
    case "$thislib" in
    dbm) thatlib=ndbm;;
    *_s) thatlib=NONE;;
    *) thatlib="${thislib}_s";;
    *) thatlib=NONE;;
    esac
    xxx=`loc lib$thislib.a X /usr/lib /usr/local/lib /lib`
    if $test -f $xxx; then
	echo "Found -l$thislib."
	case "$dflt" in
	*-l$thislib*|*-l$thatlib*);;
	*) dflt="$dflt -l$thislib";;
	esac
    else
	xxx=`loc lib$thislib.a X $libpth`
	if $test -f $xxx; then
	    echo "Found $xxx."
	    case "$dflt" in
	    *$xxx*);;
	    *) dflt="$dflt $xxx";;
	    esac
	else
	    xxx=`loc Slib$thislib.a X $xlibpth`
	    if $test -f $xxx; then
		echo "Found -l$thislib."
		case "$dflt" in
		*-l$thislib*|*-l$thatlib*);;
		*) dflt="$dflt -l$thislib";;
		esac
	    else
		echo "No -l$thislib."
	    fi
	fi
    fi
done
set X $dflt
shift
dflt="$*"
case "$libs" in
'') dflt="$dflt";;
*) dflt="$libs";;
esac
case "$dflt" in
'') dflt='none';;
esac

$cat <<EOM
 
Some versions of Unix support shared libraries, which make
executables smaller but make load time slightly longer.

On some systems, mostly newer Unix System V's, the shared library
is included by putting the option "-lc_s" as the last thing on the
cc command line when linking.  Other systems use shared libraries
by default.  There may be other libraries needed to compile $package
on your machine as well.  If your system needs the "-lc_s" option,
include it here.  Include any other special libraries here as well.
Say "none" for none.
EOM

echo " "
rp="Any additional libraries? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
libs="$ans"

: get list of predefined functions in a handy place
echo " "
case "$libc" in
'') libc=unknown;;
esac
case "$libpth" in
'') libpth='/lib /usr/lib /usr/local/lib';;
esac
case "$libs" in
*-lc_s*) libc=`loc libc_s.a $libc $libpth`
esac
libnames='';
case "$libs" in
'') ;;
*)  for thislib in $libs; do
	case "$thislib" in
	-l*) thislib=`expr X$thislib : 'X-l\(.*\)'`
	    try=`loc lib$thislib.a blurfl/dyick $libpth`
	    if test ! -f $try; then
		try=`loc lib$thislib blurfl/dyick $libpth`
		if test ! -f $try; then
		    try=`loc $thislib blurfl/dyick $libpth`
		    if test ! -f $try; then
			try=`loc Slib$thislib.a blurfl/dyick $xlibpth`
			if test ! -f $try; then
			    try=''
			fi
		    fi
		fi
	    fi
	    libnames="$libnames $try"
	    ;;
	*) libnames="$libnames $thislib" ;;
	esac
    done
    ;;
esac
set /usr/ccs/lib/libc.so
test -f $1 || set /usr/lib/libc.so
test -f $1 || set /usr/lib/libc.so.[0-9]*
eval set \$$#
if test -f "$1"; then
    echo "Your shared C library is in $1."
    libc="$1"
elif test -f /lib/libc && test -f /lib/clib; then
    echo "Your C library is in both /lib/clib and /lib/libc."
    libc='/lib/clib /lib/libc'
	if test -f /lib/syslib; then
		echo "(Your math library is in /lib/syslib.)"
		libc="$libc /lib/syslib"
	fi
elif test -f $libc; then
    echo "Your C library is in $libc, like you said before."
elif test -f /lib/libc.a; then
    echo "Your C library is in /lib/libc.a.  You're normal."
    libc=/lib/libc.a
else
    ans=`loc libc.a blurfl/dyick $libpth`
    if test ! -f "$ans"; then
	ans=`loc Slibc.a blurfl/dyick $xlibpth`
    fi
    if test ! -f "$ans"; then
	ans=`loc Mlibc.a blurfl/dyick $xlibpth`
    fi
    if test ! -f "$ans"; then
	ans=`loc Llibc.a blurfl/dyick $xlibpth`
    fi
    if test ! -f "$ans"; then
	ans=`loc libc blurfl/dyick $libpth`
    fi
    if test ! -f "$ans"; then
	ans=`loc clib blurfl/dyick $libpth`
    fi
    if test ! -f "$ans"; then
         ans=`loc libsys_s.a blurfl/dyick $libpth`
    fi
    if test -f "$ans"; then
	echo "Your C library is in $ans, of all places."
	libc=$ans
    else
	cat <<EOM
 
I can't seem to find your C library.  I've looked in the following places:

	$libpth

None of these seems to contain your C library.  What is the full name
EOM
	dflt=None
	$echo $n "of your C library? $c"
	rp='C library full name?'
	. myread
	libc="$ans"
    fi
fi
echo " "
set `echo $libc $libnames | tr ' ' '\012' | sort | uniq`
$echo $n "Extracting names from $* for later perusal...$c"
nm $* 2>/dev/null >libc.tmp
$grep printf libc.tmp > libc.ptf
com="$sed -n -e 's/^.* [ADTS]  *_[_.]*//p' -e 's/^.* [ADTS] //p'"
eval "$com <libc.ptf >libc.list"
if $contains '^printf$' libc.list >/dev/null 2>&1; then
	:
else
	com="$sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p'"
	eval "$com <libc.ptf >libc.list"
fi
if $contains '^printf$' libc.list >/dev/null 2>&1; then
	:
else
	com="$sed -n -e '/|Undef/d' -e '/|Proc/s/ .*//p'"
	eval "$com <libc.ptf >libc.list"
fi
if $contains '^printf$' libc.list >/dev/null 2>&1; then
	:
else
	com="$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p'"
	eval "$com <libc.ptf >libc.list"
fi
if $contains '^printf$' libc.list >/dev/null 2>&1; then
	:
else
	com="$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p'"
	eval "$com <libc.ptf >libc.list"
fi
if $contains '^printf$' libc.list >/dev/null 2>&1; then
	:
else
	com="$sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p'"
	eval "$com <libc.ptf >libc.list"
fi
if $contains '^printf$' libc.list >/dev/null 2>&1; then
	:
else
	com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p'"
	eval "$com <libc.ptf >libc.list"
fi
if $contains '^printf$' libc.list >/dev/null 2>&1; then
	eval "$com <libc.tmp >libc.list"
	echo "done"
else
	echo " "
	echo "nm didn't seem to work right."
	echo "Trying ar instead..."
	if ar t $libc > libc.tmp; then
		for thisname in $libnames; do
			ar t $thisname >>libc.tmp
		done
		$sed -e 's/\.o$//' < libc.tmp > libc.list
		echo "Ok."
	else
		echo "ar didn't seem to work right."
		echo "Maybe this is a Cray...trying bld instead..."
		if bld t $libc | $sed -e 's/.*\///' -e 's/\.o:.*$//' > libc.list; then
			for thisname in $libnames; do
				bld t $libnames | \
				$sed -e 's/.*\///' -e 's/\.o:.*$//' >>libc.list
				ar t $thisname >>libc.tmp
			done
			echo "Ok."
		else
			echo "That didn't work either.  Giving up."
			exit 1
		fi
	fi
fi

: define an in-header-list? function
inhdr='echo " ";
xxx=`loc $1 x /usr/include /usr/local/include $inclwanted`;
if $test -f $xxx;
then echo "<$1> found."; eval "$2=$define";
else echo "No <$1> found."; eval "$2=$undef"; fi'

: see if sys/types.h has to be included
set sys/types.h i_systypes
eval $inhdr

: see if times exists
echo " "
if $contains '^times$' libc.list >/dev/null 2>&1; then
    echo 'times() found.'
    d_times="$define"
	case "$clocktype" in
	'')
		if $contains 'clock_t;' /usr/include/sys/types.h >/dev/null 2>&1 ; then
			dflt='clock_t';
		elif $contains 'clock_t;' /usr/include/sys/times.h >/dev/null 2>&1; then
			dflt='clock_t';
		else
			dflt='long';
		fi
		;;
	*)  dflt="$clocktype"
		;;
	esac
	cont=true
	echo " "
	rp="What type is returned by times() on this sytem? [$dflt]"
	$echo $n "$rp $c"
	. myread
	clocktype="$ans"
else
    echo 'times() not found, hope that will do.'
    d_times="$undef"
	clocktype='int'
fi

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
    echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
    ;;
 ~*)
    if $test -f /bin/csh; then
	/bin/csh -f -c "glob \$1"
	echo ""
    else
	name=\`$expr x\$1 : '..\([^/]*\)'\`
	dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
	if $test ! -d "\$dir"; then
	    me=\`basename \$0\`
	    echo "\$me: can't locate home directory for: \$name" >&2
	    exit 1
	fi
	case "\$1" in
	*/*)
	    echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
	    ;;
	*)
	    echo \$dir
	    ;;
	esac
    fi
    ;;
*)
    echo \$1
    ;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: determine where manual pages are on this system
echo " "
case "$sysman" in
	'') sysman=`loc . /usr/man/man1 /usr/man/man1 /usr/man/mann /usr/man/manl /usr/man/local/man1 /usr/man/u_man/man1 /usr/share/man/man1 /usr/catman/u_man/man1 /usr/man/l_man/man1 /usr/local/man/u_man/man1 /usr/local/man/l_man/man1 /usr/man/man.L`
    ;;
esac
if test -d "$sysman"; then
	echo "System manual is in $sysman."
fi

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
if test `echo abc | tr a-z A-Z` = Abc ; then
	if $contains SIGTSTP foo >/dev/null 2>&1 ; then
	echo "Looks kind of like an USG system with BSD features, but we'll see..."
		echo exit 0 >bsd
		echo exit 0 >usg
		echo exit 1 >v7
	else
    echo "Looks kind of like an USG system, but we'll see..."
		echo exit 1 >bsd
		echo exit 0 >usg
		echo exit 1 >v7
	fi
	d_bsd="$undef"
elif $contains SIGTSTP foo >/dev/null 2>&1 ; then
    echo "Looks kind of like a BSD system, but we'll see..."
	d_bsd="$define"
    echo exit 0 >bsd
    echo exit 1 >usg
    echo exit 1 >v7
else
    echo "Looks kind of like a Version 7 system, but we'll see..."
	d_bsd="$undef"
    echo exit 1 >bsd
    echo exit 1 >usg
    echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
    cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
    echo "exit 0" >eunice
    eunicefix=unixtovms
    d_eunice="$define"
: it so happens the Eunice I know will not run shell scripts in Unix format
	;;
*)
    echo " "
    echo "Congratulations.  You aren't running Eunice."
    eunicefix=':'
    d_eunice="$undef"
    echo "exit 1" >eunice
	;;
esac
if test -f /xenix; then
    echo "Actually, this looks more like a XENIX system..."
    echo "exit 0" >xenix
	d_xenix="$define"
else
    echo " "
    echo "It's not Xenix..."
    echo "exit 1" >xenix
	d_xenix="$undef"
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
    echo "Actually, this looks more like a VENIX system..."
    echo "exit 0" >venix
else
    echo " "
    if xenix; then
	: null
    else
	echo "Nor is it Venix..."
    fi
    echo "exit 1" >venix
fi
chmod +x bsd usg v7 eunice venix
$eunicefix bsd usg v7 eunice venix
rm -f foo
rmlist="$rmlist bsd usg v7 eunice venix xenix"

: see what memory models we can support
case "$models" in
'')
    cat >pdp11.c <<'EOP'
main() {
#ifdef pdp11
    exit(0);
#else
    exit(1);
#endif
}
EOP
	cc -o pdp11 pdp11.c >/dev/null 2>&1
	if pdp11 2>/dev/null; then
		dflt='unsplit split'
	else
		ans=`loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
		case "$ans" in
		X) dflt='none';;
		*) if $test -d /lib/small || $test -d /usr/lib/small; then
				dflt='small'
			else
				dflt=''
			fi
			if $test -d /lib/medium || $test -d /usr/lib/medium; then
				dflt="$dflt medium"
			fi
			if $test -d /lib/large || $test -d /usr/lib/large; then
				dflt="$dflt large"
			fi
			if $test -d /lib/huge || $test -d /usr/lib/huge; then
				dflt="$dflt huge"
			fi
		esac
	fi;;
*) dflt="$models";;
esac
$cat <<EOM
 
Some systems have different model sizes.  On most systems they are called
small, medium, large, and huge.  On the PDP11 they are called unsplit and
split.  If your system doesn't support different memory models, say "none".
If you wish to force everything to one memory model, say "none" here and
put the appropriate flags later when it asks you for other cc and ld flags.
Venix systems may wish to put "none" and let the compiler figure things out.
(In the following question multiple model names should be space separated.)

EOM
rp="Which models are supported? [$dflt]"
$echo $n "$rp $c"
. myread
models="$ans"

case "$models" in
none)
	small=''
	medium=''
	large=''
	huge=''
	unsplit=''
	split=''
	;;
*split)
	case "$split" in
	'') if $contains '\-i' $mansrc/ld.1 >/dev/null 2>&1 || \
			 $contains '\-i' $mansrc/cc.1 >/dev/null 2>&1; then
			dflt='-i'
		else
			dflt='none'
		fi;;
	*) dflt="$split";;
	esac
	rp="What flag indicates separate I and D space? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';;
	esac
	split="$ans"
	unsplit='';;
*large*|*small*|*medium*|*huge*)
	case "$model" in
	*large*)
		case "$large" in
		'') dflt='-Ml';;
		*) dflt="$large";;
		esac
	rp="What flag indicates large model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	large="$ans";;
	*) large='';;
	esac
	case "$model" in
	*huge*) case "$huge" in
		'') dflt='-Mh';;
		*) dflt="$huge";;
		esac
		rp="What flag indicates huge model? [$dflt]"
		$echo $n "$rp $c"
		. myread
		case "$ans" in
		none) ans='';
		esac
		huge="$ans";;
    *) huge="$large";;
	esac
	case "$model" in
	*medium*) case "$medium" in
		'') dflt='-Mm';;
		*) dflt="$medium";;
		esac
		rp="What flag indicates medium model? [$dflt]"
		$echo $n "$rp $c"
		. myread
		case "$ans" in
		none) ans='';
		esac
		medium="$ans";;
    *) medium="$large";;
	esac
	case "$model" in
	*small*) case "$small" in
		'') dflt='none';;
		*) dflt="$small";;
		esac
		rp="What flag indicates small model? [$dflt]"
		$echo $n "$rp $c"
		. myread
		case "$ans" in
		none) ans='';
		esac
		small="$ans";;
	*) small='';;
	esac
	;;
*)
	echo "Unrecognized memory models--you may have to edit Makefile.SH"
	;;
esac

: see if we need a special compiler
echo " "
if usg; then
    case "$cc" in
    '')
	case "$Mcc" in
	/*) dflt='Mcc'
	    ;;
	*)
	    case "$large" in
	    -M*)
		dflt='cc'
		;;
	    *)
		if $contains '\-M' $mansrc/cc.1 >/dev/null 2>&1 ; then
		    dflt='cc -M'
		else
		    dflt='cc'
		fi
		;;
	    esac
	    ;;
	esac
	;;
    *)  dflt="$cc";;
    esac
    $cat <<'EOM'
 
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the
"Mcc" command may be used to force these to be resolved.  On other systems
a "cc -M" command is required.  (Note that the -M flag on other systems
indicates a memory model to use!)  If you have the Gnu C compiler, you
might wish to use that instead.  What command will force resolution on
EOM
	$echo $n "this system? [$dflt] $c"
	rp="Command to resolve multiple refs? [$dflt]"
	. myread
	cc="$ans"
else
	case "$cc" in
	'') dflt=cc;;
	*) dflt="$cc";;
	esac
	rp="Use which C compiler? [$dflt]"
	$echo $n "$rp $c"
	. myread
	cc="$ans"
fi
case "$cc" in
gcc*) cpp=`loc gcc-cpp $cpp $pth`;;
esac

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' ') dflt="none";;
'') dflt="-O";;
*) dflt="$optimize";;
esac
cat <<EOH

Some C compilers have problems with their optimizers, by default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might
want to use the symbolic debugger, which uses the -g flag (on traditional
Unix systems).  Either flag can be specified here.  To use neither flag,
specify the word "none".
  
EOH
rp="What optimizer/debugger flag should be used? [$dflt]"
$echo $n "$rp $c"
. myread
optimize="$ans"
case "$optimize" in
'none') optimize=" ";;
esac

case "$ccflags" in
'') case "$cc" in
	*gcc*) dflt='-fpcc-struct-return';;
	*) dflt='';;
	esac
	;;
*) dflt="$ccflags";;
esac
for thisincl in $inclwanted; do
	if $test -d $thisincl; then
		case "$dflt" in
		*$thisincl*);;
		*) dflt="$dflt -I$thisincl";;
		esac
	fi
done
case "$optimize" in
-g*)
	case "$dflt" in
	*DEBUG*);;
	*) dflt="$dflt -DDEBUG";;
	esac
	;;
esac
if $contains 'LANGUAGE_C' /usr/include/signal.h >/dev/null 2>&1; then
	case "$dflt" in
	*LANGUAGE_C*);;
	*) dflt="$dflt -DLANGUAGE_C";;
	esac
fi
case "$dflt" in
'') dflt=none;;
esac
cat <<EOH

Your C compiler may want other flags.  For this question you should
include -I/whatever and -DWHATEVER flags and any other flags used by
the C compiler, but you should NOT include libraries or ld flags like
-lwhatever.  To use no flags, specify the word "none".
  
EOH
rp="Any additional cc flags? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
ccflags="$ans"

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$cc" in
*gcc*) cppflags="$cppflags -D__GNUC__";;
esac
case "$cppflags" in
'');;
*)  set X $cppflags
	cppflags=''
	for flag do
		case $flag in
		-D*|-I*) cppflags="$cppflags $flag";;
		esac
	done
	case "$cppflags" in
	*-*)  echo "(C preprocessor flags: $cppflags)";;
	esac
	;;
esac

case "$ldflags" in
'') if venix; then
		dflt='-i -z'
	else
		dflt='none'
	fi
	;;
*) dflt="$ldflags";;
esac
echo " "
rp="Any additional ld flags (NOT including libraries)? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
ldflags="$ans"
rmlist="$rmlist pdp11"

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..."
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
echo 'Maybe "'"$cc"' -E" will work...'
$cc -E <testcpp.c >testcpp.out 2>&1
if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "Yup, it does."
    cppstdin="$cc -E"
    cppminus='';
else
    echo 'Nope, maybe "'$cpp'" will work...'
    $cpp <testcpp.c >testcpp.out 2>&1
    if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	cppstdin="$cpp"
	cppminus='';
    else
	echo 'No such luck...maybe "'$cpp' -" will work...'
	$cpp - <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	    echo "It works!"
	    cppstdin="$cpp"
	    cppminus='-';
	else
	    echo 'Nixed again...maybe "'"$cc"' -E -" will work...'
	    $cc -E - <testcpp.c >testcpp.out 2>&1
	    if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "Hooray, it works!  I was beginning to wonder."
		cppstdin="$cc -E"
		cppminus='-';
	    else
		echo 'Nope...maybe "'"$cc"' -P" will work...'
		$cc -P <testcpp.c >testcpp.out 2>&1
		if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		    echo "Yup, that does."
		    cppstdin="$cc -P"
		    cppminus='';
		else
		    echo 'Nope...maybe "'"$cc"' -P -" will work...'
		    $cc -P - <testcpp.c >testcpp.out 2>&1
		    if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
			echo "Yup, that does."
			cppstdin="$cc -P"
			cppminus='-';
		    else
			echo 'Hmm...perhaps you already told me...'
			case "$cppstdin" in
			'') ;;
			*) $cppstdin $cppminus <testcpp.c >testcpp.out 2>&1;;
			esac
			if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
			    echo "Hooray, you did!  I was beginning to wonder."
			else
			    echo 'Uh-uh.  Time to get fancy...'
			    cd ..
			    echo 'Trying (cat >/tmp/$$.c; '"$cc"' -E /tmp/$$.c; rm /tmp/$$.c)'
			    echo 'cat >/tmp/$$.c; '"$cc"' -E /tmp/$$.c; rm /tmp/$$.c' >cppstdin
			    chmod 755 cppstdin
			    cppstdin=`pwd`/cppstdin
			    cppminus='';
			    cd UU
			    $cppstdin <testcpp.c >testcpp.out 2>&1
			    if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
				echo "Eureka!."
			    else
				dflt=blurfl
				$echo $n "No dice.  I can't find a C preprocessor.  Name one: $c"
				rp='Name a C preprocessor:'
				. myread
				cppstdin="$ans"
				$cppstdin <testcpp.c >testcpp.out 2>&1
				if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
				    echo "OK, that will do."
				else
				    echo "Sorry, I can't get that to work.  Go find one."
				    exit 1
				fi
			    fi
			fi
		    fi
		fi
	    fi
	fi
    fi
fi
rm -f testcpp.c testcpp.out

: define an is-in-libc? function and set rmlist
inlibc='echo " ";
if $contains "^$1\$" libc.list >/dev/null 2>&1;
then echo "$1() found."; eval "$2=$define";
else echo "$1() not found."; eval "$2=$undef"; fi'

rmlist="$rmlist libc.tmp libc.list"

: see if memset exists
set memset d_memset
eval $inlibc

: see if bzero exists
echo " "
if $contains '^bzero$' libc.list >/dev/null 2>&1; then
    echo 'bzero() found.'
    d_bzero="$undef"
elif $test $d_memset = "$define" ; then
	echo "bzero() not found -- Will use memset() instead."
	d_bzero="$define"
else
	echo "bzero() not found."
	d_bzero="$define"
fi

: see if cbrt exists
set cbrt d_cbrt
eval $inlibc

: see which of string.h or strings.h is needed
echo " "
strings=`loc string.h "" /usr/include $inclwanted`
i_string="$undef"
if $test -r "$strings"; then
	echo "Using <string.h> instead of <strings.h>."
	if bsd; then
		echo "(Actually, this looks more like it were an USG system)"
	fi
	i_string="$define"
else
	strings=`loc strings.h "" /usr/include $inclwanted`
	if $test -r "$strings"; then
		echo "Using <strings.h> instead of <string.h>."
		if usg; then
			echo "(Actually, this looks more like it were a BSD system)"
		fi
	else
		echo "No string header found--You'll surely have problems."
	fi
fi

: index or strchr
echo " "
case "$d_index" in
n) dflt=n;;
*) dflt=y;;
esac
if $contains '^index$' libc.list >/dev/null 2>&1 ; then
	if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
		if $contains strchr "$strings" >/dev/null 2>&1 ; then
			if $contains index "$strings" >/dev/null 2>&1 ; then
				echo "Your system has both index() and strchr().  Shall I use"
				rp="index() rather than strchr()? [$dflt]"
				$echo $n "$rp $c"
				. myread
				case "$ans" in
					n*) d_index="$define" ;;
					*)  d_index="$undef" ;;
				esac
			else
				d_index="$define"
				echo "strchr() found."
			fi
		else
			d_index="$undef"
			echo "index() found."
		fi
	else
		d_index="$undef"
		echo "index() found."
	fi
else
	if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
		d_index="$define"
		echo "strchr() found."
	else
		echo "No index() or strchr() found!"
		d_index="$undef"
	fi
fi

: see if popen exists
set popen d_popen
eval $inlibc

: see if sys/resource.h has to be included
set sys/resource.h i_sysresrc
eval $inhdr

: see if we should include time.h, sys/time.h, or both
cat <<'EOM'
  
Testing to see if we should include <time.h>, <sys/time.h> or both.
I'm now running the test program...
EOM
$cat >try.c <<'EOCP'
#include <sys/types.h>
#ifdef I_TIME
#include <time.h>
#endif
#ifdef I_SYSTIME
#ifdef SYSTIMEKERNEL
#define KERNEL
#endif
#include <sys/time.h>
#endif
main()
{
    struct tm foo;
#ifdef S_TIMEVAL
    struct timeval bar;
#endif
    if (foo.tm_sec == foo.tm_sec)
	exit(0);
#ifdef S_TIMEVAL
    if (bar.tv_sec == bar.tv_sec)
	exit(0);
#endif
    exit(1);
}
EOCP
flags=''
for s_timeval in '-DS_TIMEVAL' ''; do
    for i_systimek in '' '-DSYSTIMEKERNEL'; do
	for i_time in '' '-DI_TIME'; do
	    for i_systime in '-DI_SYSTIME' ''; do
		case "$flags" in
		'') echo Trying $i_time $i_systime $i_systimek $s_timeval
		    if $cc $ccflags \
			    $i_time $i_systime $i_systimek $s_timeval \
			    try.c -o try >/dev/null 2>&1 ; then
			set X $i_time $i_systime $i_systimek $s_timeval
			shift
			flags="$*"
			echo Succeeded with $flags
		    fi
		    ;;
		esac
	    done
	done
    done
done
timeincl=''
case "$flags" in
*SYSTIMEKERNEL*) i_systimek="$define"
	timeincl='/usr/include/sys/time.h'
	echo "We'll include <sys/time.h> with KERNEL defined.";;
*) i_systimek="$undef";;
esac
case "$flags" in
*I_TIME*) i_time="$define"
	timeincl='/usr/include/time.h'
	echo "We'll include <time.h>.";;
*) i_time="$undef";;
esac
case "$flags" in
*I_SYSTIME*) i_systime="$define"
	timeincl='/usr/include/sys/time.h'
	echo "We'll include <sys/time.h>.";;
*) i_systime="$undef";;
esac
$rm -f try.c try

: see if getrusage exists
echo " "
if $contains getrusage libc.list >/dev/null 2>&1; then
    echo 'getrusage() found.'
    d_rusage="$define"
else
    echo 'getrusage() not found--cpu accounting may be less accurate.'
    d_rusage="$undef"
fi


: determine if we want to use the URT
case "$urtinc" in
'')
    dflt='none'
    ;;
*)  dflt=`echo $urtinc | $sed -e 's/-I//'`
    ;;
esac

echo " "
echo "$package works best when linked with the Utah Raster Toolkit."
echo "If you don't have the URT, $package will compile, but with many"

$cat << EOT
useful features disabled.

In addition to providing a library for reading and writing compact
image files, the URT offers a host of useful image-maniuplation tools.
You are strongly encouraged to get a copy.

If you do not have a copy of the URT, answer 'none' below.

EOT

rp="What directory holds the Utah Raster Toolkit include files? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
'none')
    urtinc=''
    urtlib=''
    d_urt="$undef"
    ;;
*)
    urtinc="$ans"
    d_urt="$define"
    case "$urtlib" in
    '')
        dflt=`$echo $urtinc | $sed -e 's/include/lib\/librle.a/g'`
        if test ! -f "$dflt"; then
            dflt="/usr/local/lib/librle.a"
        fi
        ;;
    *)
        dflt="$urtlib"
        ;;
    esac
    echo " "
    rp="Where is the Utah Raster Toolkit library? [$dflt]"
    $echo $n "$rp $c"
    . myread
    urtlib="$ans"
    urtinc="-I$urtinc"
    ;;
esac
: see if this is a stdlib.h
echo " "
if $test -r /usr/include/stdlib.h ; then
    i_stdlib="$define"
    echo "<stdlib.h> found."
else
    i_stdlib="$undef"
fi

: How can we generate normalized random numbers ?
echo " "
case "$randfunc" in
'')
	if $contains "^drand48\$" libc.list >/dev/null 2>&1; then
		dflt="drand48"
		echo "Good, found drand48()."
	elif $contains "^random\$" libc.list >/dev/null 2>&1; then
		dflt="random"
		echo "OK, found random()."
	else
		dflt="rand"
		echo "Yick, looks like I have to use rand()."
	fi
	echo " "
	;;
*)
	dflt="$randfunc"
	;;
esac
cont=true
while $test "$cont"; do
	rp="Use which function to generate random numbers? [$dflt]"
	$echo $n "$rp $c"
	. myread
	if $test "$ans" = "$dflt"; then
		: null
	else
		nrandbits=''
	fi
	randfunc="$ans"
	if $contains "^$ans\$" libc.list >/dev/null 2>&1; then
		cont=''
	else
		dflt=n
		rp="Function $ans does not exists. Use that name anyway? [$dflt]"
		$echo $n "$rp $c"
		. myread
		dflt=rand
		case "$ans" in
			[yY]*) cont='';;
		esac
	fi
	case "$cont" in
	'')
		case "$randfunc" in
		drand48)
			mrand="drand48()"
			seedfunc="srand48"
			;;
		rand*)
			case "$nrandbits" in
			'')
			echo "Checking to see how many bits your $randfunc() function produces..."
			$cat >try.c <<EOCP
#include <stdio.h>
main()
{
	register int i;
	register unsigned long tmp;
	register unsigned long max = 0L;
	extern long random();

	for (i=1000; i; i--) {
		tmp = (unsigned long)$randfunc();
		if (tmp > max) max = tmp;
	}
	for (i=0; max; i++)
		max /= 2;
	printf("%d\n",i);
}
EOCP
			if $cc try.c -o try >/dev/null 2>&1 ; then
			dflt=`try`
			else
			dflt='?'
			echo "(I can't seem to compile the test program...)"
			fi
			;;
			*)
				dflt="$nrandbits"
				;;
			esac
			rp="How many bits does your $randfunc() function produce? [$dflt]"
			$echo $n "$rp $c"
			. myread
			nrandbits="$ans"
			$rm -f try.c try
			mrand="($randfunc() / (double) ((1 << $nrandbits) -1))"
			seedfunc="srand"
			;;
		*)
			dflt="31"
			rp="How many bits does your $randfunc() function produce? [$dflt]"
			$echo $n "$rp $c"
			. myread
			nrandbits="$ans"
			seedfunc="s$randfunc"
			mrand="($randfunc() / (double) ((1 << $nrandbits) -1))"
			if $contains "^$seedfunc\$" libc.list >/dev/null 2>&1; then
				echo "(Using $seedfunc() to seed random generator)"
			else
				echo "(Warning: no $seedfunc() to seed random generator)"
				seedfunc=rand
			fi
			;;
		esac
		;;
	esac
done

: check for void type
echo " "
$cat <<EOM
Checking to see how well your C compiler groks the void type...

  Support flag bits are:
    1: basic void declarations.
    2: arrays of pointers to functions returning void.
    4: operations between pointers to and addresses of void functions.
    8: generic void pointers.

EOM
case "$voidflags" in
'')
    $cat >try.c <<'EOCP'
#if TRY & 1
void main() {
#else
main() {
#endif
	extern void moo();	/* function returning void */
	void (*goo)();		/* ptr to func returning void */
#if TRY & 8
	void *hue;		/* generic ptr */
#endif
#if TRY & 2
	void (*foo[10])();
#endif

#if TRY & 4
	if(goo == moo) {
		exit(0);
	}
#endif
	exit(0);
}
EOCP
    if $cc -S -DTRY=$defvoidused try.c >.out 2>&1 ; then
		voidflags=$defvoidused
		echo "It appears to support void."
		if $contains warning .out >/dev/null 2>&1; then
			echo "However, you might get some warnings that look like this:"
			$cat .out
		fi
    else
		echo "Hmm, your compiler has some difficulty with void.  Checking further..."
		if $cc -S -DTRY=1 try.c >/dev/null 2>&1 ; then
			echo "It supports 1..."
			if $cc -S -DTRY=3 try.c >/dev/null 2>&1 ; then
				echo "It also supports 2..."
				if $cc -S -DTRY=7 try.c >/dev/null 2>&1 ; then
					voidflags=7
					echo "And it supports 4 but not 8 definitely."
				else
					echo "It doesn't support 4..."
					if $cc -S -DTRY=11 try.c >/dev/null 2>&1 ; then
						voidflags=11
						echo "But it supports 8."
					else
						voidflags=3
						echo "Neither does it support 8."
					fi
				fi
			else
				echo "It does not support 2..."
				if $cc -S -DTRY=13 try.c >/dev/null 2>&1 ; then
					voidflags=13
					echo "But it supports 4 and 8."
				else
					if $cc -S -DTRY=5 try.c >/dev/null 2>&1 ; then
						voidflags=5
						echo "And it supports 4 but haven't heard about 8."
					else
						echo "However it supports 8 but not 4."
					fi
				fi
			fi
		else
			echo "There is no support at all for void."
			voidflags=0
		fi
    fi
esac
dflt="$voidflags";
rp="Your void support flags add up to what? [$dflt]"
$echo $n "$rp $c"
. myread
voidflags="$ans"
$rm -f try.* .out

: preserve RCS keywords in files with variable substitution, grrr
Log='$Log'
Header='$Header'
Id='$Id'

: determine where public executables go
case "$bin" in
'')
    dflt=`loc . /bin /usr/local/bin /usr/lbin /usr/local /usr/bin`
    ;;
*)  dflt="$bin"
    ;;
esac
cont=true
while $test "$cont" ; do
    echo " "
    rp="Where do you want to put the public executables? (~name ok) [$dflt]"
    $echo $n "$rp $c"
    . myread
    bin="$ans"
    bin=`filexp $bin`
    if test -d $bin; then
	cont=''
    else
	dflt=n
	rp="Directory $bin doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

: find out how to generate dependencies
echo " "
echo "Checking how to generate makefile dependencies on your machine..."
toplev=`cd ..;pwd`
ccinc="-I. -I$toplev -I$toplev/libray -I$toplev/libshade $urtinc"
$cat >dep.c <<'EOCP'
#include "dep.h"
EOCP
$cat >dep.h <<'EOCP'

EOCP
case "$mkdep" in
'')
	;;
*)
	if test -x "$mkdep" &&
		$mkdep dep.c >dep.out 2>/dev/null &&
		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
	then
		echo "$mkdep works."
	else
		mkdep=
	fi
esac

case "$mkdep" in
'')
	$spitshell > ../mkdep <<EOM
$startsh
for srcfile
do
	$cpp -M $ccinc $cppflags \$srcfile
done
EOM
	mkdep=$toplev/mkdep
	chmod +x $mkdep
	$eunicefix $mkdep
	if $mkdep dep.c >dep.out 2>/dev/null &&
		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
	then
		echo "Looks like we can use $cpp -M."
	else
		mkdep=
	fi
	;;
esac

case "$mkdep" in
'')
	$spitshell >../mkdep <<EOS
$startsh
for srcfile
do
	case "\$srcfile" in
	*.c) c='.c';;
	*.y) c='.y';;
	*.l) c='.l';;
	esac
	filebase=\`basename \$srcfile \$c\`
	< \$srcfile $cpp $cppminus $cppflags $ccinc | \\
	$sed -e '/^# *[0-9]/!d' \\
		-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
		-e 's|: \./|: |' \\
		-e 's|: *$|: '\$srcfile'|' | \\
	$grep -v '^#' | $sort | $uniq
done
EOS
	mkdep=$toplev/mkdep
	chmod +x $mkdep
	$eunicefix $mkdep
	if $mkdep dep.c >dep.out 2>/dev/null &&
		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
	then
		echo "A shell script using $cpp does the trick."
	else
		echo "$cpp doesn't seem to be any use at all."
		$spitshell >../mkdep <<EOS
$startsh
for srcfile
do
	case "\$srcfile" in
	*.c) c='.c';;
	*.y) c='.y';;
	*.l) c='.l';;
	esac
	filebase=\`basename \$srcfile \$c\`
	echo \$filebase.o: \$srcfile
	$grep '^#[  ]*include' \$srcfile /dev/null |
	$sed -e 's/#[   ]*include[  ]*//' \\
		-e 's,<\(.*\)>,"/usr/include/\1",' \\
		-e 's/:[^"]*"\([^"]*\)".*/: \1/' \\
		-e 's/\.c:/\.o:/'
done
EOS
		mkdep=$toplev/mkdep
		chmod +x $mkdep
		$eunicefix $mkdep
		if $mkdep dep.c >dep.out 2>/dev/null &&
		    $contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
		then
			cat << EOM

I can use a script with grep instead, but it will make some incorrect
dependencies, since it doesn't understand about conditional compilation.
Moreover, some dependencies may be missing, because scanning won't be
a recursive process.
If you have a program which generates makefile dependencies, you may want
to use it.  If not, you can use the script and edit the Makefile by hand
if you need to.
EOM
		else
			mkdep=
			cat << EOM

I can't seem to generate makefile dependencies at all!  Perhaps you have a
program that does?  If you don't, you might look at the mkdep script to
see if you can create one which works.
EOM
		fi
	fi
esac
cont=true
dflt="$mkdep"
while $test "$cont" ; do
	echo " "
rp="Name of program to make makefile dependencies? [$dflt]"
$echo $n "$rp $c"
. myread
mkdep="$ans"
mkdep=`filexp $mkdep`
if test -f "$mkdep"; then
	cont=''
else
	dflt=n
	rp="$mkdep doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
fi
done
$rm -f dep.c dep.h dep.o dep.out
: see if ar generates random libraries by itself
echo " "
echo "Checking how to generate random libraries on your machine..."
ar rc ran.a /dev/null
if ar ts ran.a >/dev/null 2>&1; then
	echo "ar appears to generate random libraries itself."
	orderlib=false
	ranlib=":"
else
	if test -f /usr/bin/ranlib; then
		ranlib=/usr/bin/ranlib
	elif test -f /bin/ranlib; then
		ranlib=/bin/ranlib
	fi

	if test -n "$ranlib"; then
		echo "your system has $ranlib; we'll use that."
		orderlib=false
	else
		echo "your system doesn't seem to support random libraries"
		echo "so we'll use lorder and tsort to order the libraries."
		orderlib=true
		ranlib=":"
	fi
fi

: determine compiler compiler
case "$bison" in
/*) dflt="bison -y";;
*) case "$yacc" in
		'') dflt=yacc;;
		*)  dflt="$yacc";;
	esac
	;;
esac
cont=true
    echo " "
rp="Which compiler compiler (yacc or bison -y) will you use? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
'') ans="$dflt";;
*bis*) ans="bison -y";;
*yac*) ans="yacc";;
esac
yacc="$ans"

echo " "
echo "End of configuration questions."
echo " "

: create config.sh file
echo " "
if test -d ../UU; then
    cd ..
fi
echo "Creating config.sh..."
$spitshell <<EOT >config.sh
$startsh
# config.sh
# This file was produced by running the Configure script.

d_eunice='$d_eunice'
d_xenix='$d_xenix'
d_bsd='$d_bsd'
define='$define'
eunicefix='$eunicefix'
loclist='$loclist'
expr='$expr'
awk='$awk'
sed='$sed'
echo='$echo'
cat='$cat'
chgrp='$chgrp'
chmod='$chmod'
chown='$chown'
rm='$rm'
mv='$mv'
cp='$cp'
tail='$tail'
tr='$tr'
mkdir='$mkdir'
sort='$sort'
uniq='$uniq'
grep='$grep'
trylist='$trylist'
test='$test'
inews='$inews'
egrep='$egrep'
more='$more'
pg='$pg'
Mcc='$Mcc'
vi='$vi'
mail='$mail'
bison='$bison'
cpp='$cpp'
perl='$perl'
Log='$Log'
Header='$Header'
Id='$Id'
bin='$bin'
contains='$contains'
cppstdin='$cppstdin'
cppminus='$cppminus'
d_bzero='$d_bzero'
d_cbrt='$d_cbrt'
d_index='$d_index'
d_memset='$d_memset'
d_popen='$d_popen'
d_rusage='$d_rusage'
d_times='$d_times'
clocktype='$clocktype'
i_string='$i_string'
strings='$strings'
i_sysresrc='$i_sysresrc'
i_systypes='$i_systypes'
i_time='$i_time'
i_systime='$i_systime'
i_systimek='$i_systimek'
timeincl='$timeincl'
inhdr='$inhdr'
inlibc='$inlibc'
libs='$libs'
models='$models'
split='$split'
small='$small'
medium='$medium'
large='$large'
huge='$huge'
ccflags='$ccflags'
ldflags='$ldflags'
cc='$cc'
cppflags='$cppflags'
optimize='$optimize'
n='$n'
c='$c'
orderlib='$orderlib'
ranlib='$ranlib'
package='$package'
randfunc='$randfunc'
mrand='$mrand'
seedfunc='$seedfunc'
nrandbits='$nrandbits'
spitshell='$spitshell'
shsharp='$shsharp'
sharpbang='$sharpbang'
startsh='$startsh'
sysman='$sysman'
voidflags='$voidflags'
defvoidused='$defvoidused'
yacc='$yacc'
d_urt='$d_urt'
urtinc='$urtinc'
urtlib='$urtlib'
i_stdlib='$i_stdlib'
libc='$libc'
mkdep='$mkdep'
CONFIG=true
EOT

CONFIG=true

echo " "
dflt=''
fastread=''
echo "If you didn't make any mistakes, then just type a carriage return here."
rp="If you need to edit config.sh, do it as a shell escape here:"
$echo $n "$rp $c"
. UU/myread
case "$ans" in
'') ;;
*) : in case they cannot read
    eval $ans;;
esac
. ./config.sh

echo " "
echo "Doing variable substitutions on .SH files..."
if test -f MANIFEST; then
	set x `awk '{print $1}' <MANIFEST | $grep '\.SH'`
else
	set x `find . -name "*.SH" -print`
fi
shift
case $# in
0) set x *.SH; shift;;
esac
if test ! -f $1; then
    shift
fi
for file in $*; do
    case "$file" in
    */*)
	dir=`$expr X$file : 'X\(.*\)/'`
	file=`$expr X$file : 'X.*/\(.*\)'`
	(cd $dir && . $file)
	;;
    *)
	. $file
	;;
    esac
done
if test -f config.h.SH; then
    if test ! -f config.h; then
	: oops, they left it out of MANIFEST, probably, so do it anyway.
	. config.h.SH
    fi
fi

if $contains '^depend:' Makefile >/dev/null 2>&1; then
    dflt=n
    $cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
    rp="Run make depend now? [$dflt]"
    $echo $n "$rp $c"
    . UU/myread
    case "$ans" in
    y*) make depend
	echo "Now you must run a make."
	;;
    *)  echo "You must run 'make depend' then 'make'."
	;;
    esac
elif test -f Makefile; then
    echo " "
    echo "Now you must run a make."
else
    echo "Done."
fi

$rm -f kit*isdone
: the following is currently useless
cd UU && $rm -f $rmlist
: since this removes it all anyway
cd .. && $rm -rf UU
: end of Configure
